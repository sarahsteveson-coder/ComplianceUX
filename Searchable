import React, { useEffect, useMemo, useRef, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Separator } from "@/components/ui/separator";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Search, Upload, Download, X, SlidersHorizontal, Info } from "lucide-react";
import { motion } from "framer-motion";

/**
 * User-friendly UI for a consolidated data dictionary.
 *
 * Supports:
 * - Uploading CSV (recommended) exported from your consolidation step
 * - Fast search across Display Name / Standard Name / Element ID / Notes
 * - Grouped browsing (by Display Name), with accordion
 * - Filters for Notes/Status (ESO Functionality, Progressively Disclosed, Not Enabled, Local Collection Available)
 * - Optional toggle to show Element ID-missing rows
 * - One-click export of the currently filtered view back to CSV
 *
 * Expected headers (case-insensitive best effort):
 * - Display Name (or First Column)
 * - Standard Name
 * - Element ID
 * - Notes (or Notes/Status)
 */

function normalizeHeader(h) {
  return String(h || "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ");
}

function parseCSV(text) {
  // Basic CSV parser that handles quotes.
  const rows = [];
  let i = 0;
  let field = "";
  let row = [];
  let inQuotes = false;

  const pushField = () => {
    row.push(field);
    field = "";
  };
  const pushRow = () => {
    // Ignore completely empty trailing rows
    if (row.some((c) => String(c || "").trim() !== "")) rows.push(row);
    row = [];
  };

  while (i < text.length) {
    const c = text[i];

    if (inQuotes) {
      if (c === '"') {
        const next = text[i + 1];
        if (next === '"') {
          field += '"';
          i += 2;
          continue;
        }
        inQuotes = false;
        i += 1;
        continue;
      }
      field += c;
      i += 1;
      continue;
    }

    if (c === '"') {
      inQuotes = true;
      i += 1;
      continue;
    }

    if (c === ",") {
      pushField();
      i += 1;
      continue;
    }

    if (c === "\n") {
      pushField();
      pushRow();
      i += 1;
      continue;
    }

    if (c === "\r") {
      // Handle CRLF
      const next = text[i + 1];
      if (next === "\n") {
        pushField();
        pushRow();
        i += 2;
      } else {
        i += 1;
      }
      continue;
    }

    field += c;
    i += 1;
  }

  // final
  pushField();
  pushRow();

  if (!rows.length) return { headers: [], data: [] };

  const headers = rows[0].map((h) => String(h || "").trim());
  const data = rows
    .slice(1)
    .filter((r) => r.length)
    .map((r) => {
      const obj = {};
      headers.forEach((h, idx) => {
        obj[h] = r[idx] ?? "";
      });
      return obj;
    });

  return { headers, data };
}

function toCSV(rows, headers) {
  const esc = (v) => {
    const s = String(v ?? "");
    if (/[\n\r,\"]/g.test(s)) {
      return '"' + s.replace(/\"/g, '""') + '"';
    }
    return s;
  };

  const lines = [];
  lines.push(headers.map(esc).join(","));
  for (const r of rows) {
    lines.push(headers.map((h) => esc(r[h])).join(","));
  }
  return lines.join("\n");
}

function downloadBlob(filename, content, mime) {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

const NOTE_TOKENS = [
  { key: "eso", label: "Filters: ESO Functionality", match: /\beso functionality\b/i },
  { key: "pd", label: "Filters: Progressively Disclosed", match: /\bprogressively disclosed\b/i },
  { key: "ne", label: "Filters: Not Enabled", match: /\bnot enabled\b/i },
  { key: "lca", label: "Filters: Local Collection Available", match: /\blocal collection available\b/i },
];

function noteChips(notes) {
  const s = String(notes || "");
  return NOTE_TOKENS.filter((t) => t.match.test(s));
}

function pickFields(headers) {
  // Map user CSV headers -> canonical fields
  const hNorm = headers.map((h) => ({ raw: h, n: normalizeHeader(h) }));

  const find = (candidates) => {
    for (const c of candidates) {
      const cn = normalizeHeader(c);
      const found = hNorm.find((x) => x.n === cn);
      if (found) return found.raw;
    }
    return null;
  };

  const display =
    find(["Display Name", "Name", "First Column", "Wrapper", "Patient-friendly Name"]) ||
    headers[0] ||
    null;
  const standard = find(["Standard Name", "ESO Name", "Field Name", "Description"]) || null;
  const elementId = find(["Element ID", "ElementId", "ID", "Element", "Element Id"]) || null;
  const notes = find(["Notes", "Notes/Status", "Status", "Availability", "Notes Status"]) || null;

  return { display, standard, elementId, notes };
}

function rowText(r, fieldMap) {
  const parts = [
    fieldMap.display ? r[fieldMap.display] : "",
    fieldMap.standard ? r[fieldMap.standard] : "",
    fieldMap.elementId ? r[fieldMap.elementId] : "",
    fieldMap.notes ? r[fieldMap.notes] : "",
  ];
  return parts.join(" | ").toLowerCase();
}

function compact(s) {
  return String(s ?? "").trim();
}

function KeyValue({ k, v }) {
  return (
    <div className="grid grid-cols-12 gap-2 text-sm">
      <div className="col-span-4 text-muted-foreground">{k}</div>
      <div className="col-span-8 break-words">{v ? v : <span className="text-muted-foreground">—</span>}</div>
    </div>
  );
}

function EmptyState({ onPick }) {
  return (
    <Card className="rounded-2xl shadow-sm">
      <CardHeader>
        <CardTitle className="text-xl">Upload your consolidated data dictionary</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="text-sm text-muted-foreground">
          Export your consolidated dictionary as <span className="font-medium">CSV</span> and upload it here.
          The UI will auto-detect columns like <span className="font-medium">Display Name</span>,
          <span className="font-medium"> Standard Name</span>, <span className="font-medium">Element ID</span>,
          and <span className="font-medium">Notes</span>.
        </div>

        <div className="flex flex-col gap-3 sm:flex-row">
          <Button onClick={onPick} className="rounded-2xl">
            <Upload className="mr-2 h-4 w-4" /> Choose CSV
          </Button>
          <div className="text-xs text-muted-foreground flex items-center gap-2">
            <Info className="h-4 w-4" /> Tip: keep duplicate Element IDs if they represent different wrappers.
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

export default function DataDictionaryUI() {
  const fileRef = useRef(null);

  const [headers, setHeaders] = useState([]);
  const [rawRows, setRawRows] = useState([]);
  const [fieldMap, setFieldMap] = useState({ display: null, standard: null, elementId: null, notes: null });

  const [q, setQ] = useState("");
  const [view, setView] = useState("grouped");
  const [openGroups, setOpenGroups] = useState([]);

  const [notesFilter, setNotesFilter] = useState("all");
  const [showMissingId, setShowMissingId] = useState(true);
  const [sortMode, setSortMode] = useState("az");

  useEffect(() => {
    if (headers.length) {
      setFieldMap(pickFields(headers));
    }
  }, [headers]);

  const indexed = useMemo(() => {
    if (!rawRows.length || !headers.length) return [];
    const map = fieldMap;
    return rawRows.map((r, idx) => ({
      _idx: idx,
      ...r,
      _text: rowText(r, map),
    }));
  }, [rawRows, headers, fieldMap]);

  const filtered = useMemo(() => {
    let rows = indexed;

    const query = q.trim().toLowerCase();
    if (query) {
      rows = rows.filter((r) => r._text.includes(query));
    }

    if (!showMissingId && fieldMap.elementId) {
      rows = rows.filter((r) => compact(r[fieldMap.elementId]));
    }

    if (notesFilter !== "all" && fieldMap.notes) {
      const token = NOTE_TOKENS.find((t) => t.key === notesFilter);
      if (token) {
        rows = rows.filter((r) => token.match.test(String(r[fieldMap.notes] || "")));
      }
    }

    return rows;
  }, [indexed, q, showMissingId, notesFilter, fieldMap]);

  const groups = useMemo(() => {
    if (!filtered.length) return [];
    const disp = fieldMap.display;
    const keyFor = (r) => (disp ? compact(r[disp]) : "(No display name)") || "(No display name)";

    const m = new Map();
    for (const r of filtered) {
      const k = keyFor(r);
      if (!m.has(k)) m.set(k, []);
      m.get(k).push(r);
    }

    let out = Array.from(m.entries()).map(([k, rows]) => ({ key: k, rows }));

    if (sortMode === "az") {
      out.sort((a, b) => a.key.localeCompare(b.key));
    } else if (sortMode === "za") {
      out.sort((a, b) => b.key.localeCompare(a.key));
    } else if (sortMode === "count") {
      out.sort((a, b) => b.rows.length - a.rows.length);
    }

    return out;
  }, [filtered, fieldMap, sortMode]);

  const stats = useMemo(() => {
    const total = rawRows.length;
    const shown = filtered.length;
    const uniqueIds = (() => {
      if (!fieldMap.elementId) return null;
      const s = new Set(filtered.map((r) => compact(r[fieldMap.elementId])).filter(Boolean));
      return s.size;
    })();
    return { total, shown, uniqueIds };
  }, [rawRows.length, filtered, fieldMap.elementId]);

  const onPickFile = () => fileRef.current?.click();

  const onFile = async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    const parsed = parseCSV(text);
    setHeaders(parsed.headers);
    setRawRows(parsed.data);
    setQ("");
    setNotesFilter("all");
    setShowMissingId(true);
    setOpenGroups([]);
  };

  const clear = () => {
    setHeaders([]);
    setRawRows([]);
    setQ("");
    setOpenGroups([]);
  };

  const exportFilteredCSV = () => {
    if (!headers.length) return;
    // Export with original headers, but filtered subset
    const rows = filtered.map((r) => {
      const out = {};
      headers.forEach((h) => (out[h] = r[h] ?? ""));
      return out;
    });
    const csv = toCSV(rows, headers);
    downloadBlob("filtered_data_dictionary.csv", csv, "text/csv;charset=utf-8");
  };

  const noteCounts = useMemo(() => {
    const counts = { all: filtered.length };
    NOTE_TOKENS.forEach((t) => (counts[t.key] = 0));
    if (!fieldMap.notes) return counts;
    for (const r of filtered) {
      const s = String(r[fieldMap.notes] || "");
      for (const t of NOTE_TOKENS) {
        if (t.match.test(s)) counts[t.key] += 1;
      }
    }
    return counts;
  }, [filtered, fieldMap.notes]);

  const mapReady = Boolean(fieldMap.display || fieldMap.standard || fieldMap.elementId || fieldMap.notes);

  return (
    <div className="min-h-screen bg-background p-4 sm:p-6">
      <input
        ref={fileRef}
        type="file"
        accept=".csv,text/csv"
        className="hidden"
        onChange={onFile}
      />

      <div className="mx-auto max-w-6xl space-y-4">
        <motion.div
          initial={{ opacity: 0, y: 8 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.25 }}
          className="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between"
        >
          <div>
            <div className="text-2xl font-semibold tracking-tight">Data Dictionary Explorer</div>
            <div className="text-sm text-muted-foreground">
              Search, filter, and browse your consolidated element mappings.
            </div>
          </div>
          <div className="flex flex-wrap gap-2">
            <Button variant="secondary" onClick={onPickFile} className="rounded-2xl">
              <Upload className="mr-2 h-4 w-4" /> Upload CSV
            </Button>
            <Button
              variant="secondary"
              onClick={exportFilteredCSV}
              disabled={!rawRows.length}
              className="rounded-2xl"
            >
              <Download className="mr-2 h-4 w-4" /> Export filtered CSV
            </Button>
            <Button variant="ghost" onClick={clear} disabled={!rawRows.length} className="rounded-2xl">
              <X className="mr-2 h-4 w-4" /> Reset
            </Button>
          </div>
        </motion.div>

        {!rawRows.length ? (
          <EmptyState onPick={onPickFile} />
        ) : (
          <div className="grid grid-cols-1 gap-4 lg:grid-cols-12">
            {/* Controls */}
            <Card className="rounded-2xl shadow-sm lg:col-span-4">
              <CardHeader className="space-y-1">
                <CardTitle className="text-lg flex items-center gap-2">
                  <SlidersHorizontal className="h-5 w-5" /> Controls
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <div className="text-sm font-medium">Search</div>
                  <div className="relative">
                    <Search className="absolute left-3 top-2.5 h-4 w-4 text-muted-foreground" />
                    <Input
                      value={q}
                      onChange={(e) => setQ(e.target.value)}
                      placeholder="Search name, standard name, ID, notes…"
                      className="pl-9 rounded-2xl"
                    />
                  </div>
                  <div className="text-xs text-muted-foreground">
                    Searching across detected columns{mapReady ? "" : " (headers not recognized)"}.
                  </div>
                </div>

                <Separator />

                <div className="space-y-2">
                  <div className="text-sm font-medium">Notes filter</div>
                  <Select value={notesFilter} onValueChange={setNotesFilter}>
                    <SelectTrigger className="rounded-2xl">
                      <SelectValue placeholder="All" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All ({noteCounts.all})</SelectItem>
                      {NOTE_TOKENS.map((t) => (
                        <SelectItem key={t.key} value={t.key}>
                          {t.label.replace("Filters: ", "")} ({noteCounts[t.key]})
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div className="flex items-center gap-2">
                  <Checkbox
                    id="missing-id"
                    checked={showMissingId}
                    onCheckedChange={(v) => setShowMissingId(Boolean(v))}
                  />
                  <label htmlFor="missing-id" className="text-sm">
                    Show rows with missing Element ID
                  </label>
                </div>

                <div className="space-y-2">
                  <div className="text-sm font-medium">Sort groups</div>
                  <Select value={sortMode} onValueChange={setSortMode}>
                    <SelectTrigger className="rounded-2xl">
                      <SelectValue placeholder="A → Z" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="az">A → Z</SelectItem>
                      <SelectItem value="za">Z → A</SelectItem>
                      <SelectItem value="count">Most entries</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <Separator />

                <div className="grid grid-cols-3 gap-2">
                  <Card className="rounded-2xl">
                    <CardContent className="p-3">
                      <div className="text-xs text-muted-foreground">Total rows</div>
                      <div className="text-lg font-semibold">{stats.total}</div>
                    </CardContent>
                  </Card>
                  <Card className="rounded-2xl">
                    <CardContent className="p-3">
                      <div className="text-xs text-muted-foreground">Showing</div>
                      <div className="text-lg font-semibold">{stats.shown}</div>
                    </CardContent>
                  </Card>
                  <Card className="rounded-2xl">
                    <CardContent className="p-3">
                      <div className="text-xs text-muted-foreground">Unique IDs</div>
                      <div className="text-lg font-semibold">{stats.uniqueIds ?? "—"}</div>
                    </CardContent>
                  </Card>
                </div>
              </CardContent>
            </Card>

            {/* Results */}
            <Card className="rounded-2xl shadow-sm lg:col-span-8">
              <CardHeader className="space-y-1">
                <CardTitle className="text-lg">Results</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <Tabs value={view} onValueChange={setView}>
                  <TabsList className="rounded-2xl">
                    <TabsTrigger value="grouped">Grouped</TabsTrigger>
                    <TabsTrigger value="table">Table</TabsTrigger>
                  </TabsList>

                  <TabsContent value="grouped" className="mt-4">
                    {groups.length === 0 ? (
                      <div className="text-sm text-muted-foreground">No matches.</div>
                    ) : (
                      <ScrollArea className="h-[72vh] pr-2">
                        <Accordion
                          type="multiple"
                          value={openGroups}
                          onValueChange={setOpenGroups}
                          className="space-y-2"
                        >
                          {groups.map((g) => (
                            <AccordionItem key={g.key} value={g.key} className="border rounded-2xl px-3">
                              <AccordionTrigger className="hover:no-underline">
                                <div className="flex w-full items-center justify-between gap-3 pr-2">
                                  <div className="text-left">
                                    <div className="font-medium leading-5">{g.key}</div>
                                    <div className="text-xs text-muted-foreground">{g.rows.length} mapping(s)</div>
                                  </div>
                                  <div className="flex flex-wrap justify-end gap-1">
                                    {/* show up to 3 unique element IDs as chips */}
                                    {fieldMap.elementId &&
                                      Array.from(
                                        new Set(
                                          g.rows
                                            .map((r) => compact(r[fieldMap.elementId]))
                                            .filter(Boolean)
                                        )
                                      )
                                        .slice(0, 3)
                                        .map((id) => (
                                          <Badge key={id} variant="secondary" className="rounded-xl">
                                            {id}
                                          </Badge>
                                        ))}
                                  </div>
                                </div>
                              </AccordionTrigger>
                              <AccordionContent className="pb-3">
                                <div className="space-y-3">
                                  {g.rows.map((r) => {
                                    const notes = fieldMap.notes ? r[fieldMap.notes] : "";
                                    const chips = noteChips(notes);
                                    const elementId = fieldMap.elementId ? compact(r[fieldMap.elementId]) : "";
                                    const standard = fieldMap.standard ? compact(r[fieldMap.standard]) : "";

                                    return (
                                      <Card key={r._idx} className="rounded-2xl">
                                        <CardContent className="p-4 space-y-3">
                                          <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
                                            <div className="space-y-1">
                                              <div className="text-sm font-semibold">Mapping</div>
                                              <div className="text-xs text-muted-foreground">
                                                {elementId ? `Element ID: ${elementId}` : "Element ID: —"}
                                              </div>
                                            </div>
                                            <div className="flex flex-wrap gap-1 justify-start sm:justify-end">
                                              {chips.map((c) => (
                                                <Badge key={c.key} className="rounded-xl">
                                                  {c.label.replace("Filters: ", "")}
                                                </Badge>
                                              ))}
                                            </div>
                                          </div>

                                          <div className="space-y-2">
                                            {fieldMap.standard && (
                                              <KeyValue k="Standard Name" v={standard} />
                                            )}
                                            {fieldMap.elementId && (
                                              <KeyValue k="Element ID" v={elementId} />
                                            )}
                                            {fieldMap.notes && (
                                              <KeyValue k="Notes/Status" v={compact(notes)} />
                                            )}
                                          </div>
                                        </CardContent>
                                      </Card>
                                    );
                                  })}
                                </div>
                              </AccordionContent>
                            </AccordionItem>
                          ))}
                        </Accordion>
                      </ScrollArea>
                    )}
                  </TabsContent>

                  <TabsContent value="table" className="mt-4">
                    {filtered.length === 0 ? (
                      <div className="text-sm text-muted-foreground">No matches.</div>
                    ) : (
                      <ScrollArea className="h-[72vh] pr-2">
                        <div className="overflow-hidden rounded-2xl border">
                          <table className="w-full text-sm">
                            <thead className="bg-muted/50">
                              <tr>
                                <th className="px-3 py-2 text-left font-medium">Display</th>
                                <th className="px-3 py-2 text-left font-medium">Standard</th>
                                <th className="px-3 py-2 text-left font-medium">Element ID</th>
                                <th className="px-3 py-2 text-left font-medium">Notes</th>
                              </tr>
                            </thead>
                            <tbody>
                              {filtered.map((r) => (
                                <tr key={r._idx} className="border-t">
                                  <td className="px-3 py-2 align-top">
                                    {fieldMap.display ? compact(r[fieldMap.display]) : ""}
                                  </td>
                                  <td className="px-3 py-2 align-top">
                                    {fieldMap.standard ? compact(r[fieldMap.standard]) : ""}
                                  </td>
                                  <td className="px-3 py-2 align-top">
                                    {fieldMap.elementId ? compact(r[fieldMap.elementId]) : ""}
                                  </td>
                                  <td className="px-3 py-2 align-top">
                                    <div className="flex flex-wrap gap-1">
                                      {fieldMap.notes && noteChips(r[fieldMap.notes]).length > 0 &&
                                        noteChips(r[fieldMap.notes]).map((c) => (
                                          <Badge key={c.key} className="rounded-xl">
                                            {c.label.replace("Filters: ", "")}
                                          </Badge>
                                        ))}
                                    </div>
                                    <div className="mt-1 text-muted-foreground">
                                      {fieldMap.notes ? compact(r[fieldMap.notes]) : ""}
                                    </div>
                                  </td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      </ScrollArea>
                    )}
                  </TabsContent>
                </Tabs>

                <div className="text-xs text-muted-foreground">
                  Tip: Use grouped view for browsing by patient-friendly labels; use table view for quick scanning.
                </div>
              </CardContent>
            </Card>
          </div>
        )}
      </div>
    </div>
  );
}
